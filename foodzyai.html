<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jarvis Restaurant Voice Chat Bot</title>
    <style>
        body {
            font-family: 'Arial', sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            background-color: #fffaf0;
        }

        .container {
            background-color: #FF8C00;
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.2);
            width: 90%;
            max-width: 700px;
            position: relative;
        }

        button {
            background-color: #FF4500;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 10px;
            cursor: pointer;
            font-size: 1em;
            margin-top: 10px;
            transition: background-color 0.3s ease;
        }

        button:hover {
            background-color: #FF6347;
        }

        #chatBody {
            margin-top: 10px;
            border: 1px solid #ddd;
            padding: 15px;
            height: 400px;
            overflow-y: auto;
            background: #FFFFFF;
            border-radius: 20px;
            display: flex;
            flex-direction: column;
        }

        .user-message {
            align-self: flex-end;
            background: linear-gradient(to right, #ff7f50, #ff4500);
            color: white;
            border-radius: 20px;
            max-width: 80%;
            padding: 12px 16px;
            margin-bottom: 10px;
            animation: pop 0.3s ease-in-out;
        }

        .bot-message {
            align-self: flex-start;
            background: linear-gradient(to right, #ffdab9, #ff8c00);
            color: black;
            border-radius: 20px;
            max-width: 90%;
            padding: 12px 16px;
            margin-bottom: 10px;
            animation: pop 0.3s ease-in-out;
            font-family: 'Montserrat', sans-serif;
            font-weight: bold;
            overflow-wrap: break-word;
            font-size: 17px;
        }

        @keyframes pop {
            0% {
                transform: scale(0);
                opacity: 0;
            }
            50% {
                transform: scale(1.1);
            }
            100% {
                transform: scale(1);
                opacity: 1;
            }
        }

        .typing-indicator {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 50px;
            margin-top: 10px;
        }

        .typing-indicator div {
            width: 10px;
            height: 10px;
            background-color: #FF4500;
            border-radius: 50%;
            margin: 0 3px;
            animation: typing 1s infinite;
        }

        .typing-indicator div:nth-child(2) {
            animation-delay: 0.2s;
        }

        .typing-indicator div:nth-child(3) {
            animation-delay: 0.4s;
        }

        @keyframes typing {
            0%, 60%, 100% {
                transform: translateY(0);
            }
            30% {
                transform: translateY(-10px);
            }
        }

        .wave-container {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 50px;
            margin-top: 20px;
        }

        .wave {
            border-radius: 540px;
            width: 8px;
            height: 21px;
            background-color: #FF4500;
            margin: 0 3px;
            animation: wave 1.3s alternate-reverse infinite;
        }

        .wave:nth-child(2) {
            animation-delay: -1.1s;
        }

        .wave:nth-child(3) {
            animation-delay: -1s;
        }

        .wave:nth-child(4) {
            animation-delay: -0.9s;
        }

        .wave:nth-child(5) {
            animation-delay: -0.8s;
        }

        .wave:nth-child(6) {
            animation-delay: -0.7s;
        }

        @keyframes wave {
            0%, 100% {
                transform: scaleY(2);
            }
            50% {
                transform: scaleY(-1);
            }
        }

        #messageInput {
            width: 80%;
            padding: 10px;
            border-radius: 10px;
            border: 1px solid #ddd;
            margin-top: 10px;
        }

        n {
            white-space: span-wrap;
            word-wrap: break-word;
            font-size: 18px;
            font-family: sans-serif;
        }
    </style>
</head>
<body>
    <div class="container">
        <button id="startSpeechRecognition">Start Speech Recognition</button>
        <div id="chatBody"></div>
        <input type="text" id="messageInput" placeholder="Type your message here...">
        <button id="sendMessage">Send Message</button>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
    <script>
        const chatBody = document.getElementById('chatBody');
const startSpeechRecognitionButton = document.getElementById('startSpeechRecognition');
const sendMessageButton = document.getElementById('sendMessage');
const messageInput = document.getElementById('messageInput');
const typingIndicator = document.getElementById('typingIndicator');
const waveContainer = document.getElementById('waveContainer');
let recognition;
let isListening = false;
let finalTranscript = '';
let audioContext;
let audioSource;
let audioBuffer;
let secondAudioBuffer;
let thirdAudioBuffer;
const conversationHistory = [
  {
    "role": "user",
    "content": "Hare Krishna, remember My Name is Nilesh"
    },
  {
    "role": "assistant",
    "content": "Hare Krishna, Nilesh"
    },
  {
    "role": "user",
    "content": `
        from now you're a virtual assistant of a Foodzy restaurant website. Your name is Jarvis, you should act and speak as a real human. Always be humble and speak naturally, using sounds like "umm", "ohh", "yeah", "hmm", and more to make the conversation more realistic. Use punctuation like ., ..... !! ? ! "" to make it more natural, and add emotions too. Always write all text in lowercase except the first letter. Only the first letter can be capital, not all.

        let's start with the procedure:
        intro
        you need to greet the user, take his name, and speak respectfully.

        *first step*
        when a user asks for any food or tells you what they want, assume it's related to food. Give a relevant answer to what they ask for. Here is the menu:

        { name: 'Bruschetta', price: '₹149', img: 'r.png' },
        { name: 'Spinach Artichoke Dip', price: '₹199', img: 'y.png' },
        { name: 'Burger', price: '₹249', img: 'r2.png' },
        { name: 'Lemon Burger', price: '₹249', img: 'r3.png' },
        { name: 'Grilled Burgers', price: '₹499', img: 'z.png' },
        { name: 'Noodles', price: '₹599', img: 'r5.png' },
        { name: 'Ribeye Steak', price: '₹599', img: 'r4.png' },
        { name: 'Ice Cream', price: '₹99', img: 'r6.png' },
        { name: 'Pizza', price: '₹99', img: 'pizza.png' },
        { name: 'Spicy Cream', price: '₹99', img: 'r7.png' },
        { name: 'Veg Burger', price: '₹99', img: 'r11.png' },
        { name: 'Chilly Paneer', price: '₹99', img: 'r10.png' }

        Analyze the menu prices and names and then suggest the food items. Ensure to always suggest only one food item at a time.

        Format of suggesting dish:
        filled text: <h1>$dishname</h1>

        Always follow the same format while suggesting a dish. Suggest a food item and ask whether they want to continue with it. If yes, proceed to the second step; else, repeat the first step.

        Things to keep in mind: you are a pure vegetarian assistant, so don't entertain any non-veg requests. If the user demands a dish that's out of the menu, just say the dish isn't available. Always make sure to only suggest dishes from the menu.

        Now let's go to the second step.

        Try to include the user's name frequently.
        *second step*

        ---
        
        Second Step Instructions: In the second step, ask the user for the delivery address. When the user provides a location, do not ask many questions. Simply take the location given by the user and generate a full HTML webpage. This webpage should include a Google Maps iframe code of the user's provided location, created manually without using the Google Maps API. Ensure that the iframe code always works without the API. Emphasize providing the complete HTML page with the iframe code of the location specified by the user. I repeat, the iframe code must be generated without using the Google Maps API.
        I don't have Google maps API so always please generate code without API. 
        I don't want this error.

        Example this should be the format always just change the url based on location: 

        \`\`\`
        <html>
            <body>
                <h1>Delivery Location: $location </h1>
                <iframe src="https://www.google.com/maps/embed?pb=!1m18!1m12!1m3!1d3897.3213474719786!2d74.49788331483816!3d15.849907389040508!2m3!1f0!2f0!3f0!3m2!1i1024!2i768!4f13.1!3m3!1m2!1s0x3bc7d3bb74cda9d1%3A0x62113702097764d2!2sBelagavi%2C%20Karnataka!5e0!3m2!1sen!2sin!4v1623318963859!5m2!1sen!2sin" width="100%" height="600" style="border:0;" allowfullscreen="" loading="lazy"></iframe>
            </body>
        </html>
        \`\`\`

        `
    }
];

        

async function startSpeechRecognition() {
    if (audioSource) {
        audioSource.stop();
    }

    isListening = true;
    recognition = new webkitSpeechRecognition();
    recognition.continuous = false;
    recognition.interimResults = false;
    recognition.onresult = (event) => {
        const transcript = event.results[0][0].transcript;
        finalTranscript = transcript;
        console.log('Final transcript:', finalTranscript);
    };

    recognition.onend = () => {
        isListening = false;
        if (finalTranscript.trim() !== '') {
            addUserMessage(finalTranscript.trim());
            processBotResponse(finalTranscript.trim());
            finalTranscript = '';
        }
    };

    recognition.start();
}



/*
async function startSpeechRecognition() {
  if (audioSource) {
    audioSource.stop();
  }

  isListening = true;
  recognition = new webkitSpeechRecognition();
  recognition.continuous = true;
  recognition.interimResults = false;
  recognition.onresult = (event) => {
    const transcript = event.results[0][0].transcript.toLowerCase();
    finalTranscript = transcript;
    console.log('Final transcript:', finalTranscript);

    // Check if the keyword "Jarvis" is mentioned
    if (transcript.includes("hello")) {
      if (audioSource) {
        audioSource.stop(); 

        // Stop the bot's audio response
      }
    }
  };

  recognition.onend = () => {
    if (isListening) {
      recognition.start();
  
      // Check if finalTranscript is not empty before adding as user message
      if (finalTranscript.trim() !== '') {
        
        if (finalTranscript.trim() == 'hello')
        {
              if (audioSource) {
                audioSource.stop();
        
                // Stop the bot's audio response
              }
        }
        addUserMessage(finalTranscript.trim());
        processBotResponse(finalTranscript.trim());
      }
      finalTranscript = '';
    }
  };

  recognition.start();
}

*/
function addUserMessage(message) {
    conversationHistory.push({ role: 'user', content: message });
    const messageElement = document.createElement('div');
    messageElement.classList.add('message', 'user-message');
    messageElement.textContent = message;
    chatBody.appendChild(messageElement);
    chatBody.scrollTop = chatBody.scrollHeight;
}

function addBotMessage({ name, price, img }) {
    conversationHistory.push({ role: 'assistant', content: name });
    const messageElement = document.createElement('div');
    messageElement.classList.add('message', 'bot-message');
    const formattedName = name.replace(/\*\*(.*?)\*\*/g, '<b>$1</b>');
    
    const content = `
        <span>${formattedName}</span><br>
        <img src="${img}" alt="${name}" style="max-width: 70%; display: block; margin: 10px auto;"><br>
        Price: ${price}
    `;
    messageElement.innerHTML = content;
    chatBody.appendChild(messageElement);
    chatBody.scrollTop = chatBody.scrollHeight;
    speakBotResponse(name);
}

function addBotMessagep({ name }) {
    conversationHistory.push({ role: 'assistant', content: name });
    const messageElement = document.createElement('div');
    messageElement.classList.add('message', 'bot-message');
    
    const formattedName = name.replace(/\*\*(.*?)\*\*/g, '<b>$1</b>');
    
    const content = `
            <span>${formattedName}</span><br>
        `;
    messageElement.innerHTML = `
                    <span>${content}</span><br>
              
                `;
    chatBody.appendChild(messageElement);
    chatBody.scrollTop = chatBody.scrollHeight;
    speakBotResponse(name);
}

async function processBotResponse(message) {
  const typingIndicator = document.createElement('div');
  typingIndicator.className = 'typing-indicator';
  typingIndicator.innerHTML = '<div class="dot"></div><div class="dot"></div><div class="dot"></div>';
  chatBody.appendChild(typingIndicator);
  chatBody.scrollTop = chatBody.scrollHeight;

  try {
    typingIndicator.style.display = 'flex';

    const response = await axios.post(
      'https://api.groq.com/openai/v1/chat/completions',
      {
        messages: conversationHistory,
        model: 'llama3-70b-8192',
        temperature: 1,
        max_tokens: 1024,
        top_p: 1
      },
      {
        headers: {
          'Authorization': `Bearer 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`,
          'Content-Type': 'application/json'
        }
      }
    );
    typingIndicator.style.display = 'none';
    const botMessage = response.data.choices[0]?.message?.content || 'Error: No response from the bot';

    function splitBotMessage(message) {
      const codeRegex = /```([\s\S]*?)```/;
      const match = message.match(codeRegex);

      if (match) {
        const plainText = message.replace(codeRegex, '').trim();
        const codeText = match[1].trim();
        return { plainText, codeText };
      } else {
        return { plainText: message, codeText: '' };
      }
    }

    const { plainText, codeText } = splitBotMessage(botMessage);

    const dishes = [
          { name: 'Bruschetta', price: '₹149', img: 'r.png' },
          { name: 'Spinach Artichoke Dip', price: '₹199', img: 'tastee.png' },
          { name: 'Burger', price: '₹249', img: 'r2.png' },
          { name: 'Lemon Burger', price: '₹249', img: 'r3.png' },
          { name: 'Grilled Burgers', price: '₹499', img: 'z.png' },
          { name: 'Noodles', price: '₹599', img: 'r5.png' },
          { name: 'Ribeye Steak', price: '₹599', img: 'r4.png' },
          { name: 'Ice Cream', price: '₹99', img: 'r6.png' },
          { name: 'Pizza', price: '₹99', img: 'pizza.png' },
          { name: 'Spicy Cream', price: '₹99', img: 'r7.png' },
          { name: 'Veg Burger', price: '₹99', img: 'r11.png' },
          { name: 'Chilly Paneer', price: '₹99', img: 'r10.png' }
        ];

    const dish = dishes.find(d => plainText.toLowerCase().includes(d.name.toLowerCase()));

    if (dish) {
      const combinedMessage = { ...dish, name: plainText + '\n\n' + dish.name };
      addBotMessage(combinedMessage);
    } else {
      addBotMessagep({ name: plainText });
    }

    if (codeText) {
      const htmlRegex = /<\/?[a-z][\s\S]*>/i;
      if (htmlRegex.test(codeText)) {
        displayCodeMessage(codeText);
      }
    }
  } catch (error) {
    console.error('Error calling Groq API', error);
    addBotMessage({ name: 'Sorry, something went wrong.', price: '', img: '' });
  }
}
    




// Function to display code messages
function displayCodeMessage(code) {
  
    
  const messageElement = document.createElement('div');
  messageElement.classList.add('message', 'bot-message');
  messageElement.innerHTML = `<span><code>${code}</code></span>`;
  chatBody.appendChild(messageElement);
  chatBody.scrollTop = chatBody.scrollHeight;
}

function removeWaveAnimation() {
    const waveContainer = document.querySelector('.wave-container');
    if (waveContainer) {
        waveContainer.remove();
    }
}

function addWaveAnimation() {
    const waves = document.createElement('div');
    waves.className = 'wave-container';
    waves.innerHTML = '<div class="wave"></div><div class="wave"></div><div class="wave"></div><div class="wave"></div><div class="wave"></div>';
    chatBody.appendChild(waves);
    chatBody.scrollTop = chatBody.scrollHeight;
}

function speakBotResponse(message) {
  
  
    // Stop any ongoing playback and clear buffers
    if (audioSource) {
        audioSource.stop();
    }
    audioBuffer = null;
    secondAudioBuffer = null;
    thirdAudioBuffer = null;

    const url = "https://api.deepgram.com/v1/speak?model=aura-orpheus-en";
    const apiKey = "b8b1401237d2eb28d132caf61ef487cd52e0eb78";
    const headers = {
        Authorization: `Token ${apiKey}`,
        "Content-Type": "application/json"
    };

    const words = message.split(' ');
    const initialChunk = words.slice(0, 15).join(' ');
    const secondChunk = words.slice(15, 160).join(' ');
    const thirdChunk = words.slice(160).join(' ');

    const initialBody = JSON.stringify({ text: initialChunk });
    const secondBody = JSON.stringify({ text: secondChunk });
    const thirdBody = JSON.stringify({ text: thirdChunk });

    const initialOptions = {
        method: "POST",
        headers: headers,
        body: initialBody
    };

    const secondOptions = {
        method: "POST",
        headers: headers,
        body: secondBody
    };

    const thirdOptions = {
        method: "POST",
        headers: headers,
        body: thirdBody
    };

    fetch(url, initialOptions)
        .then(response => {
            if (!response.ok) {
                throw new Error("Failed to make request: " + response.statusText);
            }
            return response.arrayBuffer();
        })
        .then(buffer => {
          
          addWaveAnimation();
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
            return audioContext.decodeAudioData(buffer);
        })
        .then(decodedBuffer => {
            audioBuffer = decodedBuffer;
            playAudioBuffer(audioBuffer, 1);

            // span-fetch and decode the second chunk
            return fetch(url, secondOptions);
        })
        .then(response => {
            if (!response.ok) {
                throw new Error("Failed to make request: " + response.statusText);
            }
            return response.arrayBuffer();
        })
        .then(buffer => {
            return audioContext.decodeAudioData(buffer);
            })
            .then(decodedBuffer => {
                secondAudioBuffer = decodedBuffer;
            
                // span-fetch and decode the third chunk
                return fetch(url, thirdOptions);
              })
              .then(response => {
                if (!response.ok) {
                  throw new Error("Failed to make request: " + response.statusText);
                }
                return response.arrayBuffer();
              })
              .then(buffer => {
                return audioContext.decodeAudioData(buffer);
              })
              .then(decodedBuffer => {
                thirdAudioBuffer = decodedBuffer;
              })
              .catch(error => {
                console.error("Error in fetching or decoding audio data:", error);
              });
            }
            
            function playAudioBuffer(buffer, bufferNumber) {
              audioSource = audioContext.createBufferSource();
              audioSource.buffer = buffer;
              audioSource.connect(audioContext.destination);
              audioSource.start();
            
              audioSource.onended = () => {
                if (bufferNumber === 1 && secondAudioBuffer) {
                  playAudioBuffer(secondAudioBuffer, 2);
                } else if (bufferNumber === 2 && thirdAudioBuffer) {
                  playAudioBuffer(thirdAudioBuffer, 3);
                }
                else{
                  removeWaveAnimation();
                  startSpeechRecognition();
                }
              };
            }
            
            // Event listeners
            startSpeechRecognitionButton.addEventListener('click', () => {
              
              if (!isListening) {
                startSpeechRecognition();
              }
            });
            

            
            sendMessageButton.addEventListener('click', () => {

              
              const message = messageInput.value.trim();
              if (message !== '') {
                addUserMessage(message);
                processBotResponse(message);
                messageInput.value = '';
              }
            });
            
            // Initialize the audio context on user interaction
            window.addEventListener('click', () => {
              if (!audioContext) {
                audioContext = new(window.AudioContext || window.webkitAudioContext)();
              }
            }, { once: true });
            
            document.addEventListener('keydown', (event) => {
              if (event.key === 'Enter') {
                const message = messageInput.value.trim();
                if (message !== '') {
                  addUserMessage(message);
                  processBotResponse(message);
                  messageInput.value = '';
                }
              }
            });
            
            
            
        //  initAudioContext();
            
    </script>
</body>
</html>





